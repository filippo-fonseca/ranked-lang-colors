{"version":3,"file":"useBaseQuery.js","sourceRoot":"","sources":["../../../../src/react/hooks/utils/useBaseQuery.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,OAAO,CAAC;AAUlE,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAC;AACvC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAE5C,OAAO,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAEjD,MAAM,UAAU,YAAY,CAC1B,KAA0D,EAC1D,OAA6C,EAC7C,IAAY;IAAZ,qBAAA,EAAA,YAAY;IAEZ,IAAM,OAAO,GAAG,UAAU,CAAC,gBAAgB,EAAE,CAAC,CAAC;IACzC,IAAA,KAAsB,UAAU,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,GAAG,CAAC,EAAL,CAAK,EAAE,CAAC,CAAC,EAA9C,IAAI,QAAA,EAAE,WAAW,QAA6B,CAAC;IACtD,IAAM,cAAc,GAAG,OAAO,CAAC,CAAC,uBAAM,OAAO,KAAE,KAAK,OAAA,IAAG,CAAC,CAAC,EAAE,KAAK,OAAA,EAAE,CAAC;IAEnE,IAAM,YAAY,GAAG,MAAM,EAAgC,CAAC;IAC5D,IAAM,SAAS,GACb,YAAY,CAAC,OAAO;QACpB,IAAI,SAAS,CAAoB;YAC/B,OAAO,EAAE,cAAqD;YAC9D,OAAO,SAAA;YACP,SAAS;gBACP,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,EAAE;oBAK7B,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBACrC;qBAAM;oBAGL,WAAW,EAAE,CAAC;iBACf;YACH,CAAC;SACF,CAAC,CAAC;IAEL,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;IACrC,SAAS,CAAC,OAAO,GAAG,OAAO,CAAC;IAK5B,IAAI,SAAS,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;QACrD,YAAY,CAAC,OAAO,GAAG,SAAS,CAAC;KAClC;IAKD,IAAM,IAAI,GAAG;QACX,OAAO,EAAE,sBACJ,cAAc,KACjB,OAAO,EAAE,SAAS,EAClB,WAAW,EAAE,SAAS,GACgB;QACxC,OAAO,SAAA;QACP,IAAI,MAAA;KACL,CAAC;IAEF,IAAM,MAAM,GAAG,WAAW,CACxB,cAAM,OAAA,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,EAAtD,CAAsD,EAC5D,IAAI,CACL,CAAC;IAEF,IAAM,WAAW,GAAG,IAAI;QACtB,CAAC,CAAE,MAAwC,CAAC,CAAC,CAAC;QAC9C,CAAC,CAAE,MAAyC,CAAC;IAE/C,SAAS,CAAC;QAGR,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;YACzB,YAAY,CAAC,OAAO,GAAG,SAAS,CAAC;SAClC;QAED,OAAO,cAAM,OAAA,SAAS,CAAC,OAAO,EAAE,EAAnB,CAAmB,CAAC;IACnC,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,SAAS,CAAC,cAAM,OAAA,SAAS,CAAC,YAAY,CAAC,EAAE,IAAI,MAAA,EAAE,CAAC,EAAhC,CAAgC,EAAE;QAChD,WAAW,CAAC,OAAO;QACnB,WAAW,CAAC,aAAa;QACzB,WAAW,CAAC,KAAK;QACjB,WAAW,CAAC,IAAI;KACjB,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["import { useContext, useEffect, useReducer, useRef } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  QueryHookOptions,\n  QueryDataOptions,\n  QueryTuple,\n  QueryResult,\n} from '../../types/types';\nimport { QueryData } from '../../data';\nimport { useDeepMemo } from './useDeepMemo';\nimport { OperationVariables } from '../../../core';\nimport { getApolloContext } from '../../context';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n  const queryData =\n    queryDataRef.current ||\n    new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryDataOptions<TData, TVariables>,\n      context,\n      onNewData() {\n        if (!queryData.ssrInitiated()) {\n          // When new data is received from the `QueryData` object, we want to\n          // force a re-render to make sure the new data is displayed. We can't\n          // force that re-render if we're already rendering however so to be\n          // safe we'll trigger the re-render in a microtask.\n          Promise.resolve().then(forceUpdate);\n        } else {\n          // If we're rendering on the server side we can force an update at\n          // any point.\n          forceUpdate();\n        }\n      }\n    });\n\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // SSR won't trigger the effect hook below that stores the current\n  // `QueryData` instance for future renders, so we'll handle that here if\n  // the current render is happening on the server side.\n  if (queryData.ssrInitiated() && !queryDataRef.current) {\n    queryDataRef.current = queryData;\n  }\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: {\n      ...updatedOptions,\n      onError: undefined,\n      onCompleted: undefined\n    } as QueryHookOptions<TData, TVariables>,\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  useEffect(() => {\n    // We only need one instance of the `QueryData` class, so we'll store it\n    // as a ref to make it available on subsequent renders.\n    if (!queryDataRef.current) {\n      queryDataRef.current = queryData;\n    }\n\n    return () => queryData.cleanup();\n  }, []);\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data,\n  ]);\n\n  return result;\n}\n"]}