{"version":3,"file":"reactiveVars.js","sourceRoot":"","sources":["../../../src/cache/inmemory/reactiveVars.ts"],"names":[],"mappings":"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","sourcesContent":["import { Slot } from \"@wry/context\";\nimport { dep } from \"optimism\";\nimport { InMemoryCache } from \"./inMemoryCache\";\nimport { ApolloCache } from '../../core';\n\nexport interface ReactiveVar<T> {\n  (newValue?: T): T;\n  onNextChange(listener: ReactiveListener<T>): () => void;\n  attachCache(cache: ApolloCache<any>): this;\n  forgetCache(cache: ApolloCache<any>): boolean;\n}\n\nexport type ReactiveListener<T> = (value: T) => any;\n\nconst varDep = dep<ReactiveVar<any>>();\n\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport const cacheSlot = new Slot<ApolloCache<any>>();\n\n// A listener function could in theory cause another listener to be added\n// to the set while we're iterating over it, so it's important to commit\n// to the original elements of the set before we begin iterating. See\n// iterateObserversSafely for another example of this pattern.\nfunction consumeAndIterate<T>(set: Set<T>, callback: (item: T) => any) {\n  if (set.size) {\n    const items: T[] = [];\n    set.forEach(item => items.push(item));\n    set.clear();\n    items.forEach(callback);\n  }\n}\n\nconst varsByCache = new WeakMap<ApolloCache<any>, Set<ReactiveVar<any>>>();\n\nexport function forgetCache(cache: ApolloCache<any>) {\n  const vars = varsByCache.get(cache);\n  if (vars) {\n    consumeAndIterate(vars, rv => rv.forgetCache(cache));\n    varsByCache.delete(cache);\n  }\n}\n\nexport function makeVar<T>(value: T): ReactiveVar<T> {\n  const caches = new Set<ApolloCache<any>>();\n  const listeners = new Set<ReactiveListener<T>>();\n\n  const rv: ReactiveVar<T> = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue!;\n        // First, invalidate any fields with custom read functions that\n        // consumed this variable, so query results involving those fields\n        // will be recomputed the next time we read them.\n        varDep.dirty(rv);\n        // Next, broadcast changes to any caches that have previously read\n        // from this variable.\n        caches.forEach(broadcast);\n        // Finally, notify any listeners added via rv.onNextChange.\n        consumeAndIterate(listeners, listener => listener(value));\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      const cache = cacheSlot.getValue();\n      if (cache) attach(cache);\n      varDep(rv);\n    }\n\n    return value;\n  };\n\n  rv.onNextChange = listener => {\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  };\n\n  const attach = rv.attachCache = cache => {\n    caches.add(cache);\n    let vars = varsByCache.get(cache)!;\n    if (!vars) varsByCache.set(cache, vars = new Set);\n    vars.add(rv);\n    return rv;\n  };\n\n  rv.forgetCache = cache => {\n    const deleted = caches.delete(cache);\n    if (deleted) {\n      const vars = varsByCache.get(cache);\n      if (vars) vars.delete(rv);\n    }\n    return deleted;\n  };\n\n  return rv;\n}\n\ntype Broadcastable = ApolloCache<any> & {\n  // This method is protected in InMemoryCache, which we are ignoring, but\n  // we still want some semblance of type safety when we call it.\n  broadcastWatches?: InMemoryCache[\"broadcastWatches\"];\n};\n\nfunction broadcast(cache: Broadcastable) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n"]}