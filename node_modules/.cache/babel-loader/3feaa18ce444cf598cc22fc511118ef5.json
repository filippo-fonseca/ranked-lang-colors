{"ast":null,"code":"import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null);\n  var fromName; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      var dependents = depGraph[fromName];\n\n      if (dependents === undefined) {\n        dependents = depGraph[fromName] = Object.create(null);\n      }\n\n      dependents[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i2) {\n    var operation = operations[_i2];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies[node.name.value];\n      })\n    };\n  };\n\n  for (var _i2 = 0; _i2 < operations.length; _i2++) {\n    _loop(_i2);\n  }\n\n  return separatedDocumentASTs;\n} // Provides the empty string for anonymous operations.\n\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    for (var _i4 = 0, _Object$keys2 = Object.keys(immediateDeps); _i4 < _Object$keys2.length; _i4++) {\n      var toName = _Object$keys2[_i4];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/filippofonseca/Developer/open-source/ranked-lang-colors/node_modules/graphql/utilities/separateOperations.mjs"],"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","fromName","OperationDefinition","node","opName","push","FragmentDefinition","name","value","FragmentSpread","toName","dependents","undefined","separatedDocumentASTs","_loop","_i2","operation","operationName","dependencies","collectTransitiveDependencies","kind","DOCUMENT","definitions","filter","FRAGMENT_DEFINITION","length","collected","immediateDeps","_i4","_Object$keys2","keys"],"mappings":"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","sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null);\n  var fromName; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      var dependents = depGraph[fromName];\n\n      if (dependents === undefined) {\n        dependents = depGraph[fromName] = Object.create(null);\n      }\n\n      dependents[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i2) {\n    var operation = operations[_i2];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies[node.name.value];\n      })\n    };\n  };\n\n  for (var _i2 = 0; _i2 < operations.length; _i2++) {\n    _loop(_i2);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    for (var _i4 = 0, _Object$keys2 = Object.keys(immediateDeps); _i4 < _Object$keys2.length; _i4++) {\n      var toName = _Object$keys2[_i4];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}