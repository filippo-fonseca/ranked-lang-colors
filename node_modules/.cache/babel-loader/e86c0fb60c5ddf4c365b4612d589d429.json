{"ast":null,"code":"import Observable from 'zen-observable';\nimport 'symbol-observable';\n\nObservable.prototype['@@observable'] = function () {\n  return this;\n};\n\nexport { Observable };","map":{"version":3,"sources":["../../../src/utilities/observables/Observable.ts"],"names":[],"mappings":"AAAA,OAAO,UAAP,MAAuB,gBAAvB;AAIA,OAAO,mBAAP;;AAeC,UAAU,CAAC,SAAX,CAA6B,cAA7B,IAA+C,YAAA;AAAc,SAAO,IAAP;AAAc,CAA3E;;AACD,SAAS,UAAT","sourcesContent":["import Observable from 'zen-observable';\n\n// This simplified polyfill attempts to follow the ECMAScript Observable\n// proposal (https://github.com/zenparsing/es-observable)\nimport 'symbol-observable';\n\nexport type ObservableSubscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\n// Use global module augmentation to add RxJS interop functionality. By\n// using this approach (instead of subclassing `Observable` and adding an\n// ['@@observable']() method), we ensure the exported `Observable` retains all\n// existing type declarations from `@types/zen-observable` (which is important\n// for projects like `apollo-link`).\ndeclare global {\n  interface Observable<T> {\n    ['@@observable'](): Observable<T>;\n  }\n}\n(Observable.prototype as any)['@@observable'] = function () { return this; };\nexport { Observable };\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}