{"ast":null,"code":"import { Observable } from \"./Observable.js\";\nexport function asyncMap(observable, mapFn, catchFn) {\n  return new Observable(function (observer) {\n    var next = observer.next,\n        error = observer.error,\n        complete = observer.complete;\n    var activeCallbackCount = 0;\n    var completed = false;\n\n    function makeCallback(examiner, delegate) {\n      if (examiner) {\n        return function (arg) {\n          ++activeCallbackCount;\n          new Promise(function (resolve) {\n            return resolve(examiner(arg));\n          }).then(function (result) {\n            --activeCallbackCount;\n            next && next.call(observer, result);\n\n            if (completed) {\n              handler.complete();\n            }\n          }, function (e) {\n            --activeCallbackCount;\n            error && error.call(observer, e);\n          });\n        };\n      } else {\n        return function (arg) {\n          return delegate && delegate.call(observer, arg);\n        };\n      }\n    }\n\n    var handler = {\n      next: makeCallback(mapFn, next),\n      error: makeCallback(catchFn, error),\n      complete: function () {\n        completed = true;\n\n        if (!activeCallbackCount) {\n          complete && complete.call(observer);\n        }\n      }\n    };\n    var sub = observable.subscribe(handler);\n    return function () {\n      return sub.unsubscribe();\n    };\n  });\n}","map":{"version":3,"sources":["../../../src/utilities/observables/asyncMap.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,QAAqC,iBAArC;AAIA,OAAM,SAAU,QAAV,CACJ,UADI,EAEJ,KAFI,EAGJ,OAHI,EAGwC;AAE5C,SAAO,IAAI,UAAJ,CAAkB,UAAA,QAAA,EAAQ;AACvB,QAAA,IAAI,GAAsB,QAAQ,CAA9B,IAAJ;AAAA,QAAM,KAAK,GAAe,QAAQ,CAAvB,KAAX;AAAA,QAAa,QAAQ,GAAK,QAAQ,CAAb,QAArB;AACR,QAAI,mBAAmB,GAAG,CAA1B;AACA,QAAI,SAAS,GAAG,KAAhB;;AAEA,aAAS,YAAT,CACE,QADF,EAEE,QAFF,EAEsC;AAEpC,UAAI,QAAJ,EAAc;AACZ,eAAO,UAAA,GAAA,EAAG;AACR,YAAE,mBAAF;AACA,cAAI,OAAJ,CAAY,UAAA,OAAA,EAAO;AAAI,mBAAA,OAAO,CAAC,QAAQ,CAAhB,GAAgB,CAAT,CAAP;AAAsB,WAA7C,EAA+C,IAA/C,CACE,UAAA,MAAA,EAAM;AACJ,cAAE,mBAAF;AACA,YAAA,IAAI,IAAI,IAAI,CAAC,IAAL,CAAU,QAAV,EAAoB,MAApB,CAAR;;AACA,gBAAI,SAAJ,EAAe;AACb,cAAA,OAAO,CAAC,QAAR;AACD;AACF,WAPH,EAQE,UAAA,CAAA,EAAC;AACC,cAAE,mBAAF;AACA,YAAA,KAAK,IAAI,KAAK,CAAC,IAAN,CAAW,QAAX,EAAqB,CAArB,CAAT;AACD,WAXH;AAaD,SAfD;AAgBD,OAjBD,MAiBO;AACL,eAAO,UAAA,GAAA,EAAG;AAAI,iBAAA,QAAQ,IAAI,QAAQ,CAAC,IAAT,CAAc,QAAd,EAAZ,GAAY,CAAZ;AAAwC,SAAtD;AACD;AACF;;AAED,QAAM,OAAO,GAAgB;AAC3B,MAAA,IAAI,EAAE,YAAY,CAAC,KAAD,EAAQ,IAAR,CADS;AAE3B,MAAA,KAAK,EAAE,YAAY,CAAC,OAAD,EAAU,KAAV,CAFQ;AAG3B,MAAA,QAAQ,EAAA,YAAA;AACN,QAAA,SAAS,GAAG,IAAZ;;AACA,YAAI,CAAC,mBAAL,EAA0B;AACxB,UAAA,QAAQ,IAAI,QAAQ,CAAC,IAAT,CAAc,QAAd,CAAZ;AACD;AACF;AAR0B,KAA7B;AAWA,QAAM,GAAG,GAAG,UAAU,CAAC,SAAX,CAAqB,OAArB,CAAZ;AACA,WAAO,YAAA;AAAM,aAAA,GAAG,CAAH,WAAA,EAAA;AAAiB,KAA9B;AACD,GA5CM,CAAP;AA6CD","sourcesContent":["import { Observable, Observer } from \"./Observable\";\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | PromiseLike<R>,\n  catchFn?: (error: any) => R | PromiseLike<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeCallbackCount = 0;\n    let completed = false;\n\n    function makeCallback(\n      examiner: typeof mapFn | typeof catchFn,\n      delegate: typeof next | typeof error,\n    ): (arg: any) => void {\n      if (examiner) {\n        return arg => {\n          ++activeCallbackCount;\n          new Promise(resolve => resolve(examiner(arg))).then(\n            result => {\n              --activeCallbackCount;\n              next && next.call(observer, result);\n              if (completed) {\n                handler.complete!();\n              }\n            },\n            e => {\n              --activeCallbackCount;\n              error && error.call(observer, e);\n            },\n          );\n        };\n      } else {\n        return arg => delegate && delegate.call(observer, arg);\n      }\n    }\n\n    const handler: Observer<V> = {\n      next: makeCallback(mapFn, next),\n      error: makeCallback(catchFn, error),\n      complete() {\n        completed = true;\n        if (!activeCallbackCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}